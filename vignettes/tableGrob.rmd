Displaying tables as grid graphics
=================================
<!-- 
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{tableGrob}
-->

```{r setup, echo=FALSE, results='hide'}
library(knitr)
opts_chunk$set(message=FALSE, fig.width=4, fig.height=2)
```

Tabular data is usually formatted outside the graphics device, e.g via LaTeX, or html tables. However, in some cases it may be convenient to display *small* tables alongside graphics. A couple of packages offer this possibility with base graphics (`plotrix` for instance); the `gridExtra` provides the pair of `tableGrob/grid.table` functions for this purpose. Note that the tables are quite inefficient, each cell containing two individual grobs.

```{r basic}
library(gridExtra)
library(grid)
d <- head(iris[,1:3])
grid.table(d)
```

The spacing of each row/column is automatic, and will adjust to bigger cell contents. Plotmath notation may be used, with the `parse=TRUE` argument. Note that this is applied to individual strings of text, and reverts to standard text if parsing fails (this is useful when mixing multiline text with plotmath in different cells).

```{r annotations, fig.height=3}
d[2,3] <- "this is very wwwwwide"
d[1,2] <- "this\nis\ntall"
colnames(d) <- c("alpha*integral(xdx,a,infinity)", 
                 "this text\nis high", 'alpha/beta')

tt <- ttheme_default(colhead=list(parse=TRUE))
grid.table(d, theme=tt)

```

The formatting is controlled by *themes*, which are nested lists of graphical parameters. See `ttheme_default` and `ttheme_minimal` for two built-in examples. Changing a few parameters at a time amounts to modifying the list with the new values.

```{r theme, fig.width=8}
tt1 <- ttheme_default()
tt2 <- ttheme_minimal()
tt3 <- ttheme_minimal(core=list(bg.par = list(fill = blues9, col=NA)), colhead=list(fg.par=list(col="navyblue")))
grid.arrange(
tableGrob(iris[1:4, 1:2], theme=tt1),
tableGrob(iris[1:4, 1:2], theme=tt2),
tableGrob(iris[1:4, 1:2], theme=tt3),
nrow=1)
```

Being based on `gtable`, the table can be further processed. In particular, we may edit the cell sizes to align with other content on the page.

```{r sizes, fig.width=8}
g <- g2 <- tableGrob(iris[1:4, 1:3], cols = NULL, rows=NULL)
g2$widths <- unit(rep(1/ncol(g2), ncol(g2)), "npc")
grid.arrange(rectGrob(), rectGrob(), nrow=1)
grid.arrange(g, g2, nrow=1, newpage = FALSE)
```

We may also access individual cells, e.g. to highlight a value.


```{r highlight}
g <- tableGrob(iris[1:4, 1:3])
find_cell <- function(table, row, col, name="core-fg"){
  l <- table$layout
  which(l$t==row & l$l==col & l$name == name)
}
  
ind <- find_cell(g, 3, 2, "core-fg")
ind2 <- find_cell(g, 3, 2, "core-bg")
g$grobs[ind][[1]][["gp"]] <- gpar(fontsize=15, fontface="bold")
g$grobs[ind2][[1]][["gp"]] <- gpar(fill="darkolivegreen1")
grid.draw(g)
```


